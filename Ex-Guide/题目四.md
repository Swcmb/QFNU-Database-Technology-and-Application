# 题目四实验指南：并发控制与存储分析

## 第一阶段：环境与工具准备

### 1. 准备两个并发会话

在 Linux 终端中，您可以通过以下两种方式准备会话：

- **方式 A（推荐）**：打开两个 SSH 远程终端窗口。
- **方式 B**：在一个窗口中使用 `tmux` 或 `screen` 工具分屏。

在两个窗口中分别输入以下命令登录数据库：

Bash

```
# 会话 A (Session A)
psql -U uxdb

# 会话 B (Session B)
psql -U uxdb
```

*注：为了便于区分，建议将会话 A 的提示符修改为 `SET PROMPT1 'Session_A=# ';`*

### 2. 初始化插件与数据

在 **Session A** 执行：

SQL

```
-- 安装查看物理页的插件
CREATE EXTENSION IF NOT EXISTS pageinspect;

-- 创建测试表并插入一条数据
DROP TABLE IF EXISTS lock_test;
CREATE TABLE lock_test (id int, name text);
INSERT INTO lock_test VALUES (1, 'uxdb_init');
```

------

## 第二阶段：演示 3 种锁冲突场景

### 场景 1：行级写-写冲突（Row-Level Lock）

此场景演示两个事务同时修改同一行数据的互斥性。

- **Session A**:

  SQL

  ```
  BEGIN;
  UPDATE lock_test SET name = 'A' WHERE id = 1;
  ```

- **Session B**:

  SQL

  ```
  UPDATE lock_test SET name = 'B' WHERE id = 1;
  ```

- **观察与监控**: 在 **Session A** 中查询锁状态：

  SQL

  ```
  SELECT locktype, mode, granted, pid 
  FROM pg_locks 
  WHERE relation = 'lock_test'::regclass;
  ```

  你会看到 Session B 的 `granted` 字段为 `f` (false)，表示正在等待锁。

   Session A 执行 
   
   ```
   COMMIT;
  ```

### 场景 2：表级 DDL 与 DML 冲突

此场景演示“读取”操作如何阻止“表结构修改”操作。

- **Session A**:

  SQL

  ```
  BEGIN;
  SELECT * FROM lock_test;
  ```

- **Session B**:

  SQL

  ```
  DROP TABLE lock_test;
  ```

- **现象**: Session B 阻塞，直到 Session A 执行 `COMMIT;`。

- **观察与监控**: 在 **Session A** 中查询锁状态：

  SQL

  ```
  SELECT locktype, mode, granted, pid 
  FROM pg_locks 
  WHERE relation = 'lock_test'::regclass;
  ```

  你会看到 Session B 的 `granted` 字段为 `f` (false)，表示正在等待锁。
  
   Session A 执行 
   
   ```
   COMMIT;
  ```


### 场景 3：手动显式锁冲突

此场景演示最高级别的排他锁会阻塞所有其他操作（包括读取）。

- **Session A**:

  SQL

  ```
  CREATE TABLE lock_test (id int, name text);
  INSERT INTO lock_test VALUES (1, 'uxdb_init');
  
  BEGIN;
  LOCK TABLE lock_test IN ACCESS EXCLUSIVE MODE;
  ```

- **Session B**:

  SQL

  ```
  SELECT * FROM lock_test;
  ```

- **现象**: 即使是简单的 `SELECT` 也会被阻塞。

   Session A 执行 
   
   ```
   COMMIT;
  ```

------

## 第三阶段：锁冲突原理深入分析

**原理详解（以场景 1 为例）：**

1. **行锁标记**：当 Session A 执行更新时，它并不是在内存中维护一个庞大的行锁表，而是修改该行的元组头部的 `xmax` 字段。
2. **事务 ID 检查**：当 Session B 尝试更新时，发现该行已标记了 `xmax`（Session A 的事务 ID）。
3. **队列等待**：Session B 会去查看 Session A 是否已提交。如果未提交，Session B 会进入等待队列，其进程 ID 会被挂起。
4. **释放机制**：UXDB 使用两阶段锁协议（2PL），事务持有的所有锁（包括行标记）只有在 `COMMIT` 或 `ROLLBACK` 时才会统一释放。

------

## 第四阶段：使用 pageinspect 查看 DML 物理变化

在 **Session A** 执行，确保表存在且插件已加载：

SQL

```
ROLLBACK; -- 确保退出之前失败的事务块
DROP TABLE IF EXISTS lock_test;
CREATE TABLE lock_test (id int, name text);
INSERT INTO lock_test VALUES (1, 'uxdb_init');
CREATE EXTENSION IF NOT EXISTS pageinspect;
```

------

### 第二步：重新演示写-写冲突（场景 1）

1. **Session A**:

   SQL

   ```
   BEGIN;
   UPDATE lock_test SET name = 'Session_A' WHERE id = 1;
   SELECT txid_current(); 
   ```

   *假设此时显示的 ID 是 `848`。*

2. **Session B**:

   SQL

   ```
   UPDATE lock_test SET name = 'Session_B' WHERE id = 1;
   -- 这里会卡住，正常的现象
   ```

3. **原理分析**：

   此时 Session B 发现该行元组的隐藏字段 `xmax` 已经被标记为 `848`。由于事务 `848` 尚未提交，Session B 必须在 `pg_locks` 中注册一个等待，直到 Session A 结束。

------

### 第三步：使用 pageinspect 查看物理字段变化

在 **Session A** 执行提交后，我们观察磁盘上发生的变化：

1. **Session A 执行提交**:

   SQL

   ```
   COMMIT;
   ```

   *此时 Session B 会解除阻塞并显示 UPDATE 1。请也把 Session B 提交或结束。*

2. **Session A 查看物理页面 (Page 0)**:

   SQL

   ```
   SELECT lp, t_ctid, t_xmin, t_xmax, t_data 
   FROM heap_page_items(get_raw_page('lock_test', 0));
   ```

#### 实验结果解读：

你会看到类似下面的输出：

| **lp (行指针)** | **t_ctid (物理位置)** | **t_xmin** | **t_xmax** | **t_data**        |
| --------------- | --------------------- | ---------- | ---------- | ----------------- |
| 1               | (0,2)                 | 1999       | **848**    | \x... (initial)   |
| 2               | (0,3)                 | **848**    | **2002**   | \x... (Session_A) |
| 3               | (0,3)                 | **2002**   | 0          | \x... (Session_B) |

**核心字段变化说明：**

- **t_xmax 的意义**：
  - 在 `lp=1` 的行上，`t_xmax` 变成了 `848`。这代表该版本被事务 848 “删除”了。
  - 在 `lp=2` 的行上，`t_xmax` 变成了 `2002`（假设 Session B 的 ID 是 2002）。
- **t_ctid 的演变（版本链）**：
  - 旧行的 `t_ctid` 不再指向自己，而是指向新版本的位置（如从 `(0,1)` 指向 `(0,2)`）。这就是 UXDB 追踪数据更新历程的“线索”。
- **t_xmin**：
  - 新产生的 `lp=2` 行，其 `t_xmin` 正是执行更新的事务 ID（848）。

总结：

通过这个实验，你可以明确看到：在 UXDB 中，更新不是原地覆盖。每执行一次 DML，底层都会保留旧版本并打上“过期标记”（xmax），同时增加新版本。这些旧版本在没有活跃事务引用后，最终会由 VACUUM 进程回收。