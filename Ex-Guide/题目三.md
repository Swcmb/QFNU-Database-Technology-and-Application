# 实验三：CREATE TABLE / INSERT 操作对应的 WAL 日志分析

> 本实验在 **实验二（物理存储结构）** 的基础上，进一步分析
> **DDL / DML 操作在 WAL（Write-Ahead Log）中的体现方式**。

## 一、实验目标

通过本实验，你将掌握：

- CREATE TABLE / INSERT 是否产生 WAL
- WAL 记录的物理含义（不是 SQL 文本）
- 如何用 **LSN 精确截取 WAL**
- 如何将 **WAL 记录 ↔ 表 / 索引 / Page / txid** 对应起来
- WAL 与 **checkpoint / redo 点** 的关系

## 二、WAL 基础说明（重要概念）

📌 **关键结论（必须理解）**：

> WAL 中 **不记录 SQL 语句本身**，
> 而是记录 **物理 / 逻辑修改操作**

| SQL 操作     | WAL 中的表现               |
| ------------ | -------------------------- |
| CREATE TABLE | Storage + Heap + Btree WAL |
| INSERT       | Heap INSERT + Btree INSERT |
| COMMIT       | Transaction COMMIT WAL     |

## 三、实验准备：确认 WAL 环境

### 3.1 检查 WAL 级别

```sql
SHOW wal_level;
```

应至少为：

```
replica
```

> replica 已能完整看到 CREATE / INSERT 的 WAL
> logical 不是必须

### 3.2 确认 WAL 目录位置

```sql
SHOW data_directory;
```

WAL 实际目录为：

```bash
/home/uxdb/uxdb/pg_wal
```

### 3.3 确认 pg_waldump 工具

```bash
\q
pg_waldump --version
```

📌 `pg_waldump` 是 **唯一标准 WAL 解析工具**

###  临时关闭自动 checkpoint

```
psql -U uxdb
ALTER SYSTEM SET checkpoint_timeout = '60min';
ALTER SYSTEM SET max_wal_size = '1GB';
SELECT pg_reload_conf();
```

📌 目的：**防止 WAL 被提前回收**

## 四、CREATE TABLE 对应的 WAL 分析

### 4.1 记录操作前 LSN（起点）

```sql
SELECT pg_current_wal_lsn();
```

假设返回：

```
0/1BC1B80
```

📌 **这是 WAL 截取起点**

### 4.2 执行 CREATE TABLE

```sql
DROP TABLE IF EXISTS t_wal;

CREATE TABLE t_wal (
    id INT,
    info TEXT
);
```

### 4.3 再次记录 LSN（终点）

```sql
SELECT pg_current_wal_lsn();
```

假设返回：

```
0/1BC1B80
```

### 4.4 定位并分析 WAL 文件

退出数据库：

```sql
\q
```

#### Step 1: 定位 WAL 文件

```bash
ls /home/uxdb/uxdb/pg_wal/
```

你会看到类似：

```
00000001000000000000001B
00000001000000000000001C
```

#### Step 2: 使用 pg_waldump 解析 WAL

```bash
pg_waldump /home/uxdb/uxdb/pg_wal/00000001000000000000001B
```

> **注意**: pg_waldump 在解析 WAL 文件末尾时，由于存在尚未写入的空白区域，会提示 invalid record length 错误，该现象并不表示 WAL 损坏，而是 WAL 解析已到达有效记录边界。
>

### 4.5 观察 CREATE TABLE 产生的 WAL 类型

你将看到类似输出：

```text
rmgr: Storage     desc: CREATE rel 1663/16387/24644
rmgr: Heap        desc: INSERT off 3
rmgr: Btree       desc: INSERT_LEAF off 7
rmgr: Transaction desc: COMMIT
```

#### WAL 记录解释

| WAL 类型           | 含义                   |
| ------------------ | ---------------------- |
| Storage CREATE     | 创建新的 relation 文件 |
| Heap INSERT        | 向系统表写入一条元数据 |
| Btree INSERT       | 更新系统表索引         |
| Transaction COMMIT | CREATE TABLE 提交      |

📌 **结论**：

> CREATE TABLE 本质是
> **向 pg_class / pg_attribute 等系统表插入元组**

## 五、INSERT 操作对应的 WAL 分析

### 5.1 再次记录 LSN（INSERT 起点）


```
psql -U uxdb
SELECT pg_current_wal_lsn();
```

假设：

```
0/1BC1BB8
```

### 5.2 执行 INSERT 操作

```sql
INSERT INTO t_wal
SELECT i, 'wal_' || i
FROM generate_series(1, 100) i;
```

### 5.3 记录 INSERT 后 LSN

```sql
SELECT pg_current_wal_lsn();
```

假设：

```
0/1BC3850
```

### 5.4 定位并分析 WAL 文件

退出数据库：

```sql
\q
```

#### Step 1: 定位 WAL 文件

```bash
ls /home/uxdb/uxdb/pg_wal/
```

你会看到类似：

```
00000001000000000000001B
00000001000000000000001C
```

#### Step 2: 使用 pg_waldump 解析 WAL

```bash
pg_waldump /home/uxdb/uxdb/pg_wal/00000001000000000000001B
```

> **注意**: pg_waldump 在解析 WAL 文件末尾时，由于存在尚未写入的空白区域，会提示 invalid record length 错误，该现象并不表示 WAL 损坏，而是 WAL 解析已到达有效记录边界。

### 5.5 INSERT 对应的 WAL 典型输出

```text
rmgr: Heap
desc: INSERT off 5 flags 0x00
blkref #0: rel 1663/16387/24644 blk 0

rmgr: Btree
desc: INSERT_LEAF off 12

rmgr: Transaction
desc: COMMIT
```

### 5.6 WAL 字段含义解析（重点）

```text
rel 1663/16387/24644 blk 0 off 5
```

| 字段  | 含义               |
| ----- | ------------------ |
| 1663  | 表空间（default）  |
| 16387 | 数据库 OID         |
| 24644 | 表的 relfilenode   |
| blk 0 | 第 0 个 heap page  |
| off 5 | page 内 tuple 偏移 |

📌 **这正是你在实验二中看到的 heap page**

## 六、WAL 与 Heap Page 的对应验证（强烈推荐）

### 6.1 查询表 relfilenode

```sql
psql -U uxdb
SELECT relfilenode
FROM pg_class
WHERE relname = 't_wal';
```

假设：

```
24644
```

### 6.2 查看对应 heap page

```sql
SELECT *
FROM heap_page_items(get_raw_page('t_wal', 0));
```

📌 你将看到：

- tuple 的 `xmin`
- tuple 的偏移位置
- 与 WAL 中 `blk/off` 完全对应

## 七、事务维度：INSERT 对应的 txid 与 WAL

### 7.1 获取当前事务 ID

```sql
SELECT txid_current();
```

假设：

```
8223
```

### 7.2 在 WAL 中查找事务提交记录

退出数据库：

```bash
\q
```

#### Step 1: 列出 WAL 文件

```bash
ls /home/uxdb/uxdb/pg_wal
```

你会看到类似：

```
00000001000000000000001B
00000001000000000000001C
archive_status/
```

#### Step 2: 查找 Transaction 类型的 WAL 记录

```bash
pg_waldump --rmgr=Transaction /home/uxdb/uxdb/pg_wal/00000001000000000000001B
```

你会看到：

```text
desc: COMMIT 2025-01-03 tx 8223
```

📌 **完成 SQL → txid → WAL 的映射**

### 补充说明：DDL 操作的事务特性

在执行 CREATE TABLE 与 INSERT 操作后，使用 pg_waldump 对 WAL 日志进行解析时，你可能会在 Transaction rmgr 中观察到大量 COMMIT 记录。这是由于：

1. **系统目录表更新**：DDL 操作会触发 pg_class、pg_attribute 等系统表的更新
2. **缓存失效**：catcache、relcache 等缓存需要失效并重新加载
3. **统计信息维护**：PostgreSQL 会自动更新表的统计信息

这些内部操作通常以多个独立事务形式提交，因此在 WAL 中会看到多个 COMMIT 记录。同时，通过 Heap 和 Btree 资源管理器可以观察到数据行插入与索引页更新的 WAL 记录，这验证了 PostgreSQL WAL 对数据与元数据的完整记录机制。

## 八、WAL、checkpoint 与 redo 的关系回顾

### 8.1 查看 checkpoint 信息（SQL）

```sql
psql -U uxdb
SELECT * FROM pg_control_checkpoint();
```

重点字段：

| 字段           | 含义            |
| -------------- | --------------- |
| checkpoint_lsn | 最近 checkpoint |
| redo_lsn       | 崩溃恢复起点    |

### 8.2 文件级验证（最权威）

```bash
\q
pg_controldata /home/uxdb/uxdb
```

关键输出：

```
Latest checkpoint location
Latest checkpoint's REDO location
```

📌 **数据库恢复从 redo_lsn 开始重放 WAL**


重新连接数据库：

```bash
psql -U uxdb
```

### 恢复为默认值

```
ALTER SYSTEM RESET checkpoint_timeout;
ALTER SYSTEM RESET max_wal_size;
SELECT pg_reload_conf();
\q
```


## 九、实验结论总结（可直接写入实验报告）

> 1. CREATE TABLE 和 INSERT 均会产生 WAL
> 2. WAL 不记录 SQL 文本，而记录物理修改
> 3. CREATE TABLE 本质是系统表的 Heap / Btree 插入
> 4. INSERT 对应 Heap Page 的 tuple 写入
> 5. pg_waldump + LSN 可以精确定位 WAL
> 6. WAL 与 heap page 的 blk/off 可一一对应
> 7. redo_lsn 决定数据库崩溃恢复起点
